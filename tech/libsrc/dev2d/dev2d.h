/* This File Automatically Generated by the build system */ 
#include <fix.h>
#include <matrixs.h> 
#ifndef __DEV2D_H 
#define  __DEV2D_H 
// $Header: x:/prj/tech/libsrc/dev2d/RCS/emode.h 1.1 1996/09/26 15:20:19 KEVIN Exp $

#ifdef __cplusplus
extern "C" {
#endif

/* definitions for all supported device-independent graphics modes. */
enum {
   GRM_320x200x8,       // mode 13h
   GRM_320x200x8X,      // X for mode x mode
   GRM_320x400x8,       // this is also mode x
   GRM_320x240x8,       // and this
   GRM_320x480x8,       // and this

// NOTE: Be sure to change GRM_FIRST_SVGA_MODE in mode.h if the next entry changes!

   GRM_640x350x4,       
   GRM_640x400x4,       
   GRM_640x480x4,       
   GRM_800x600x4,       
   GRM_1024x768x4,      
   GRM_1280x1024x4,     
   GRM_1600x1200x4,     

   GRM_320x200x8S,
   GRM_320x240x8S,      
   GRM_320x400x8S,      
   GRM_360x200x8,
   GRM_360x240x8,      
   GRM_360x400x8,      
   GRM_640x350x8,       
   GRM_640x400x8,       
   GRM_640x480x8,       
   GRM_800x600x8,       
   GRM_1024x768x8,      
   GRM_1280x1024x8,     
   GRM_1600x1200x8,     

   GRM_320x200x15,      
   GRM_320x240x15,      
   GRM_320x400x15,      
   GRM_360x200x15,      
   GRM_360x240x15,      
   GRM_360x400x15,      
   GRM_640x350x15,      
   GRM_640x400x15,      
   GRM_640x480x15,      
   GRM_800x600x15,      
   GRM_1024x768x15,     
   GRM_1280x1024x15,    
   GRM_1600x1200x15,    

   GRM_320x200x16,      
   GRM_320x240x16,      
   GRM_320x400x16,      
   GRM_360x200x16,      
   GRM_360x240x16,      
   GRM_360x400x16,      
   GRM_640x350x16,      
   GRM_640x400x16,      
   GRM_640x480x16,      
   GRM_800x600x16,      
   GRM_1024x768x16,     
   GRM_1280x1024x16,    
   GRM_1600x1200x16,    

   GRM_320x200x24,      
   GRM_320x240x24,      
   GRM_320x400x24,      
   GRM_360x200x24,      
   GRM_360x240x24,      
   GRM_360x400x24,      
   GRM_640x350x24,      
   GRM_640x400x24,      
   GRM_640x480x24,      
   GRM_800x600x24,      
   GRM_1024x768x24,     
   GRM_1280x1024x24,    
   GRM_1600x1200x24,    

   GRM_320x200x32,      
   GRM_320x240x32,      
   GRM_320x400x32,      
   GRM_360x200x32,      
   GRM_360x240x32,      
   GRM_360x400x32,      
   GRM_640x350x32,      
   GRM_640x400x32,      
   GRM_640x480x32,      
   GRM_800x600x32,      
   GRM_1024x768x32,     
   GRM_1280x1024x32,    
   GRM_1600x1200x32,    

   GRM_400x300x8,      
   GRM_512x384x8,      
   GRM_400x300x15,      
   GRM_512x384x15,      
   GRM_400x300x16,      
   GRM_512x384x16,      
   GRM_400x300x24,      
   GRM_512x384x24,      
   GRM_400x300x32,      
   GRM_512x384x32,

   GRD_MODES,           // 77 modes
};
#ifdef __cplusplus
};
#endif

// $Header: x:/prj/tech/libsrc/dev2d/RCS/grs.h 1.7 1998/04/28 13:47:25 KEVIN Exp $

#ifdef __cplusplus
extern "C" {
#endif

/* system information structure. */
typedef struct grs_sys_info {
   uchar id_maj;     /* major id---type of graphics system */
   uchar id_min;     /* minor id---vendor */
   short memory;     /* memory in kilobytes */
   short modes[GRD_MODES+1]; /* array of modes, ends with -1 */
} grs_sys_info;

/* mode information descriptor structure.  The global structure
   contains the information which we think should hold.  All of
   it is checked, and if any does not match the data obtained
   from the vesa bios call, it is flaged as unsupported.  We also
   fill in the granularity and the linear framebuffer flag on
   init. */

typedef struct grs_mode_info {
   short mode_2d;    /* internal 2d mode value */
   short mode_vesa;  /* vesa mode number or -1 if non-vesa */
   short w;          /* screen width in mode */
   short h;          /* screen height in mode */
   uchar bitDepth;   /* number of bits per pixel */
   uchar flags;      /* internal bits defined below */
   short bankShift;  /* we save the amount to shift the bank by */
} grs_mode_info;     /* 12 bytes long */

/* Defines for the flags field in grs_mode_info */
#define GRM_IS_SUPPORTED   1     /* whether given graphics mode is supported       */
#define GRM_IS_LINEAR      2     /* whether the mode can use a linear frame buffer */
#define GRI_USE_WINA       4     /* whether winA is both read/writable             */
#define GRM_IS_MODEX       8     /* whether the mode is a mode x mode              */
#define GRM_IS_NATIVE      16    /* whether the mode is native or "emulated"       */
#define GRM_CAN_FULLSCREEN 32    /* whether the mode can be full screen            */
#define GRM_CAN_WINDOW     64    /* whether the mode can be in a window            */

/* amazing rgb type. */
typedef ulong grs_rgb;

/* hey, it's an rgb bitmask */
typedef struct grs_rgb_bitmask {
   ulong red, green, blue;
} grs_rgb_bitmask;

/* structure for bitmaps to be drawn from and to.  if a bitmap is contained
   within a larger bitmap, the row field tells how wide the containing bitmap
   is. */
typedef struct grs_bitmap {
   uchar *bits;      /* ptr to data */
   uchar type;       /* type of data in bitmap, 1-bit, 8-bit, etc */
   uchar align;      /* where data really starts */
   ushort flags;     /* whether compressed, transparent, etc */
   short w;          /* width in pixels */
   short h;          /* height */
   ushort row;       /* bytes in row of containing bitmap */
   uchar wlog;       /* log2 of w */
   uchar hlog;       /* log2 of h */
} grs_bitmap;

/* stencil element for non-rectangular clipping. */
typedef struct grs_sten_elem {
   short l;                   /* left edge of stencil */
   short r;                   /* right */
   struct grs_sten_elem *n;   /* pointer to next span in this scanline */
} grs_sten_elem;

/* stencil header for non-rectangular clipping. */
typedef struct grs_stencil {
   grs_sten_elem *elem;    /* pointer to first stencil element */
   long flags;             /* specific stencil data. */
} grs_stencil;

/* structure for clipping regions.  a clipping region can either be a simple
   rectangle (given by left,top,right,bot) or a grs_stencil, pointed to by
   sten. */
typedef union {
   struct grs_fix_clip {
      grs_stencil *sten;  /* pointer to stencil for nonrect clip region */
      fix left;            /* current clipping rectangle */
      fix top;             /* fixed-point coordinates */
      fix right;
      fix bot;
   } f;
   struct grs_int_clip {
      grs_stencil *sten;  /* pointer to stencil for nonrect clip region */
      short pad0;
      short left;          /* current clipping rectangle */
      short pad1;
      short top;           /* integral coordinates */
      short pad2;
      short right;
      short pad3;
      short bot;
   } i;
} grs_clip;

/* structure for drawing context.  the context contains data about which
   color, font attributes, filling attributes, and an embedded clipping
   region structure. */
typedef struct grs_context {
   long fcolor;      /* current drawing color */
   long bcolor;      /* background color */
   void *font;       /* font pointer */
   long text_attr;   /* attributes for text */
   long fill_type;   /* how to fill primitives */
   long fill_parm;   /* parameter for fill */
   grs_clip clip;    /* clipping region */
   grs_clip safe_clip;  /* safe clipping region */ 
} grs_context;

/* a canvas is a bitmap   drawing context. */
typedef struct grs_canvas {
   grs_bitmap  bm;   /* bitmap to draw into/read out of */
   grs_context gc;   /* graphic context */
   int *ytab;        /* pointer to an optional y table */
} grs_canvas;

/* a screen is a descriptor for a visible region of video memory. */
typedef struct grs_screen {
   grs_bitmap bm;    /* where we actually draw */
   grs_bitmap bm2;   /* second video buffer for WIN32 */
   grs_canvas *c;    /* pointer to 2 system canvases */
   short x;          /* upper left coordinates of visible */
   short y;          /* region of virtual buffer */
} grs_screen;

/* driver capability/info structure. */
typedef struct grs_drvcap {
   fix aspect;       /* fixed point aspect ratio w/h */
   short w;          /* screen width */
   short h;          /* screen height */
   uchar *vbase;     /* base video address */
   uchar *vbase2;    /* base video address */
   ulong rowBytes;   /* bytes per scanline */
} grs_drvcap;

/* 3d point structure for perspective mapper. */
typedef struct grs_point3d {
   fix x,y,z;    /* 3's */
} grs_point3d;

#ifdef __cplusplus
};
#endif

// $Header: x:/prj/tech/libsrc/dev2d/RCS/bitmap.h 1.7 1998/03/12 10:40:16 KEVIN Exp $

#ifdef __cplusplus
extern "C" {
#endif

/* bitmap types. */
/*
   for compatability with old data, we _must_ have
      BMT_MONO = 1, BMT_FLAT8=2, BMT_RSD8 = 4
 */
enum {
   BMT_MODEX,
   BMT_MONO,
   BMT_FLAT8,
   BMT_FLAT16,
   BMT_RSD8,
   BMT_FLAT24,
   BMT_BANK8,
   BMT_BANK16,
   BMT_BANK24,
   BMT_TLUC8,
   BMT_TYPES
};
/*
   BMT_DEVICE_VIDMEM and BMT_DEVICE_VIDMEM_TO_FLAT are hacks for gr_init_bm()
   to produce bitmaps of the appropriate type for the current mode.
*/
#define BMT_DEVICE_VIDMEM BMT_TYPES
#define BMT_DEVICE_VIDMEM_TO_FLAT BMT_TYPES+1

/* bitmap flags. */
enum {
   BMF_OPAQUE,
   BMF_TRANS,
   BMF_TYPES
};
#define BMF_TLUC8          0x2
#define BMF_TLUC           0x2
#define BMF_DEVICE_VIDMEM  0x4
#define BMF_DEVICE_SYSMEM  0x8
#define BMF_DEVICE         (BMF_DEVICE_VIDMEM | BMF_DEVICE_SYSMEM)
#define BMF_DEV_MUST_BLIT 0x10
#define BMF_POW2          0x20
#define BMF_RELOCATABLE 0x8000

/* additional rgb format "flags" for upper 8 bits of flags field */
#define BMF_RGB_INDEX    0x000
#define BMF_RGB_332      0x100
#define BMF_RGB_1555     0x200
#define BMF_RGB_555      0x300
#define BMF_RGB_565      0x400
#define BMF_RGB_888      0x500
#define BMF_RGB_8888     0x600
#define BMF_RGB_4444     0x700
#define BMF_RGB_1232     0x800

#define gr_test_bitmap_format(bm, format) (((bm)->flags&0x7f00) == (format))
#define gr_set_bitmap_format(bm, format) (bm)->flags = (ushort )(((bm)->flags&0x80ff)|(format))

/* function prototypes for bitmap routines. */
extern void gr_init_bitmap
   (grs_bitmap *bm, uchar *p, uint type, uint flags, int w, int h);
extern void gr_init_sub_bitmap
   (grs_bitmap *sbm, grs_bitmap *dbm, int x, int y, int w, int h);
extern void gr_init_sub_bitmap_unsafe
   (grs_bitmap *sbm, grs_bitmap *dbm, int x, int y, int w, int h);
extern grs_bitmap *gr_alloc_bitmap
   (uint type, uint flags, int w, int h);
extern void gr_calc_sub_bitmap
   (grs_bitmap *bm, int x, int y);

/* returns the flat memory model type for the given bitmap type */
extern uint gr_bm_type_to_flat(uint type);

/* must call this under windows when done using a bitmap that points to direct draw memory. */
extern void gr_close_bitmap(grs_bitmap *bm);

#define gr_close_bm gr_close_bitmap
#define gr_close_sub_bitmap gr_close_bitmap
#define gr_close_sub_bm gr_close_bitmap

/* compatibility defines. */
#define gr_init_bm gr_init_bitmap
#define gr_init_sub_bm gr_init_sub_bitmap
#define gr_init_sub_bm_unsafe gr_init_sub_bitmap_unsafe
#define gr_alloc_bm gr_alloc_bitmap

#ifdef __cplusplus
};
#endif

// $Header: x:/prj/tech/libsrc/dev2d/RCS/canvas.h 1.4 1998/04/28 13:46:38 KEVIN Exp $

#ifdef __cplusplus
extern "C" {
#endif

typedef void (*set_canvas_func)(grs_canvas *f);
extern void gr_set_canvas (grs_canvas *c);
extern int gr_install_set_canvas_callback(set_canvas_func f);
extern void gr_uninstall_set_canvas_callback(int cb_id);
extern void gr_make_canvas (grs_bitmap *bm, grs_canvas *c);
extern void gr_init_canvas (grs_canvas *c, uchar *p, uint type,
                            int w, int h);
extern void gr_init_sub_canvas (grs_canvas *sc, grs_canvas *dc,
                                int x, int y, int w, int h);
extern void gr_close_canvas(grs_canvas *c);
#define gr_close_sub_canvas gr_close_canvas
extern grs_canvas *gr_alloc_canvas (int id, int w, int h);
//XXX Chaos
//extern gr_free_canvas (grs_canvas *c);
extern int gr_free_canvas (grs_canvas *c);
extern grs_canvas *gr_alloc_sub_canvas (grs_canvas *c, int x, int y,
                                        int w, int h);
extern void gr_free_sub_canvas (grs_canvas *c);

extern int gr_push_canvas (grs_canvas *c);
extern grs_canvas *gr_pop_canvas (void);

extern void gr_alloc_ytab(grs_canvas *c);
extern void gr_free_ytab(grs_canvas *c);

#ifdef __cplusplus
};
#endif

/*
 * $Source: x:/prj/tech/libsrc/dev2d/RCS/screen.h $
 * $Revision: 1.2 $
 * $Author: TOML $
 * $Date: 1997/01/08 16:49:34 $
 *
 * Screen handling prototypes.
 *
 * This file is part of the dev2d library.
 *
 */

#ifdef __cplusplus
extern "C" {
#endif

extern grs_screen *gr_alloc_screen (int w, int h);
extern void gr_free_screen (grs_screen *s);
extern void gr_set_screen (grs_screen *s);

#ifdef __cplusplus
};
#endif

// $Header: x:/prj/tech/libsrc/dev2d/RCS/mode.h 1.6 1997/11/21 11:56:32 KEVIN Exp $

#ifdef __cplusplus
extern "C" {
#endif

#define GRM_FIRST_SVGA_MODE GRM_640x350x4

// Translate 'x' to 'X' from mode list in emode.h

enum {
   GRM_320X200X8,
   GRM_320X200X8X,
   GRM_320X400X8,
   GRM_320X240X8,
   GRM_320X480X8,

   GRM_640X350X4,
   GRM_640X400X4,
   GRM_640X480X4,
   GRM_800X600X4,
   GRM_1024X768X4,
   GRM_1280X1024X4,
   GRM_1600X1200X4,

   GRM_320X200X8S,
   GRM_320X240X8S,
   GRM_320X400X8S,
   GRM_360X200X8,
   GRM_360X240X8,
   GRM_360X400X8,
   GRM_640X350X8,
   GRM_640X400X8,
   GRM_640X480X8,
   GRM_800X600X8,
   GRM_1024X768X8,
   GRM_1280X1024X8,
   GRM_1600X1200X8,

   GRM_320X200X15,
   GRM_320X240X15,
   GRM_320X400X15,
   GRM_360X200X15,
   GRM_360X240X15,
   GRM_360X400X15,
   GRM_640X350X15,
   GRM_640X400X15,
   GRM_640X480X15,
   GRM_800X600X15,
   GRM_1024X768X15,
   GRM_1280X1024X15,
   GRM_1600X1200X15,

   GRM_320X200X16,
   GRM_320X240X16,
   GRM_320X400X16,
   GRM_360X200X16,
   GRM_360X240X16,
   GRM_360X400X16,
   GRM_640X350X16,
   GRM_640X400X16,
   GRM_640X480X16,
   GRM_800X600X16,
   GRM_1024X768X16,
   GRM_1280X1024X16,
   GRM_1600X1200X16,

   GRM_320X200X24,
   GRM_320X240X24,
   GRM_320X400X24,
   GRM_360X200X24,
   GRM_360X240X24,
   GRM_360X400X24,
   GRM_640X350X24,
   GRM_640X400X24,
   GRM_640X480X24,
   GRM_800X600X24,
   GRM_1024X768X24,
   GRM_1280X1024X24,
   GRM_1600X1200X24,

   GRM_320X200X32,
   GRM_320X240X32,
   GRM_320X400X32,
   GRM_360X200X32,
   GRM_360X240X32,
   GRM_360X400X32,
   GRM_640X350X32,
   GRM_640X400X32,
   GRM_640X480X32,
   GRM_800X600X32,
   GRM_1024X768X32,
   GRM_1280X1024X32,
   GRM_1600X1200X32,

   GRM_400X300X8,
   GRM_512X384X8,
   GRM_400X300X15,
   GRM_512X384X15,
   GRM_400X300X16,
   GRM_512X384X16,
   GRM_400X300X24,
   GRM_512X384X24,
   GRM_400X300X32,
   GRM_512X384X32,

};

// Define the flags to send gr_set_mode.  Done so that TRUE (=1) and
// FALSE (=0) still work as they used to.

#define MODE_CLEAR_BIT  1
#define MODE_LINEAR_BIT 2

#define NO_CLEAR_BANKED 0
#define CLEAR_BANKED    1
#define NO_CLEAR_LINEAR 2
#define CLEAR_LINEAR    (MODE_CLEAR_BIT | MODE_LINEAR_BIT)

#ifdef _WIN32
#define MODE_WINDOWED      0x000000004
#define MODE_FULLSCREEN    0x000000008
#else
#define MODE_WINDOWED      0x000000000
#define MODE_FULLSCREEN    0x000000000
#endif

extern grs_mode_info grd_mode_info[];
extern int gr_set_mode (int mode, uint flags);

// Enumerated mode <--> Mode info conversions
#define gr_mode_info_from_mode(mode) (&grd_mode_info[(mode)])
extern int gr_mode_from_info(int w, int h, int bitDepth);
extern const char * gr_mode_name(int mode);

// Finds the first 2d mode with w,h, and bitdepth
// Note it doesn't care about flat, linear, banked, or anything else
// Hopefully the 2d is organized with flat first.
extern int gr_find_mode(int w, int h, int bitDepth);

// find mode from specified -1 terminated list
extern int gr_find_mode_list(int w, int h, int bitDepth, short *mode_list);

// Also checks for all the flag bits set
extern int gr_find_mode_flags(int w,int h,int bitDepth,uchar flags);

// find mode from specified -1 terminated list
extern int gr_find_mode_flags_list(int w,int h,int bitDepth,uchar flags,short *mode_list);

#define gr_mode_linear(mode) (grd_mode_info[(mode)].flags & GRM_IS_LINEAR)
#define gr_mode_supported(mode) (grd_mode_info[(mode)].flags & GRM_IS_SUPPORTED)
#define gr_mode_flat(mode) (gr_mode_linear(mode)||(mode==GRM_320x200x8))
#define grd_bpp (grd_mode_info[grd_mode].bitDepth)

#ifdef __cplusplus
};
#endif

// $Header: x:/prj/tech/libsrc/dev2d/RCS/alpha.h 1.2 1996/12/06 15:29:30 KEVIN Exp $

typedef mxs_real alpha_real;

typedef struct alpha_vector {
   union {
      mxs_vector v;
      struct {
         alpha_real blue, green, red;
      };
   };
} alpha_vector;

/*
 * $Source: s:/prj/tech/libsrc/dev2d/RCS/fill.h $
 * $Revision: 1.1 $
 * $Author: KEVIN $
 * $Date: 1996/04/10 16:35:29 $
 *
 * Fill constants.
 *
 * This file is part of the dev2d library.
 *
 */

#ifdef __cplusplus
extern "C" {
#endif

enum {
   FILL_NORM,
   FILL_CLUT,
   FILL_XOR,
   FILL_BLEND,
   FILL_SOLID,
   FILL_TYPES
};

#ifdef __cplusplus
};
#endif

/*
 * $Source: s:/prj/tech/libsrc/dev2d/RCS/clip.h $
 * $Revision: 1.1 $
 * $Author: KEVIN $
 * $Date: 1996/04/10 16:52:00 $
 *
 * Prototypes for 2d clippers, constants for clipping codes.
 *
 * This file is part of the dev2d library.
 */

#ifdef __cplusplus
extern "C" {
#endif

/* clip codes. */
#define CLIP_NONE    0
#define CLIP_LEFT    1
#define CLIP_TOP     2
#define CLIP_RIGHT   4
#define CLIP_BOT     8
#define CLIP_ALL     16

#ifdef __cplusplus
};
#endif

/*
 * $Source: s:/prj/tech/libsrc/dev2d/RCS/icanvas.h $
 * $Revision: 1.1 $
 * $Author: KEVIN $
 * $Date: 1996/04/10 16:55:10 $
 *
 * Canvas function table indexes.
 *
 * This file is part of the dev2d library.
 */

#ifdef __cplusplus
extern "C" {
#endif

enum {
   GDC_UPIX,
   GDC_UPIX_EXPOSE,

   GDC_UPIX8,
   GDC_UPIX8_EXPOSE,

   GDC_UPIX16,
   GDC_UPIX16_EXPOSE,

   GDC_UPIX24,
   GDC_UPIX24_EXPOSE,

   GDC_LPIX,
   GDC_LPIX_EXPOSE,

   GDC_LPIX8,
   GDC_LPIX8_EXPOSE,

   GDC_LPIX16,
   GDC_LPIX16_EXPOSE,

   GDC_LPIX24,
   GDC_LPIX24_EXPOSE,

   GDC_UGPIX8,
   GDC_UGPIX8_EXPOSE,

   GDC_UGPIX16,
   GDC_UGPIX16_EXPOSE,

   GDC_UGPIX24,
   GDC_UGPIX24_EXPOSE,

   GDC_UBITMAP,
   GDC_UBITMAP_EXPOSE,

   GDC_UHLINE,
   GDC_UHLINE_EXPOSE,
   GDC_UVLINE,
   GDC_UVLINE_EXPOSE,

   GDC_CANVAS_FUNCS
};

#ifdef __cplusplus
};
#endif

/*
 * $Source: x:/prj/tech/libsrc/dev2d/RCS/idevice.h $
 * $Revision: 1.2 $
 * $Author: KEVIN $
 * $Date: 1998/03/12 10:41:01 $
 *
 * Symbolic constants for function table references.
 *
 * This file is part of the dev2d library.
 *
 */

#ifdef __cplusplus
extern "C" {
#endif

enum {
   GDC_INIT_DEVICE,
   GDC_CLOSE_DEVICE,
   GDC_SET_MODE,
   GDC_GET_MODE,
   GDC_SAVE_STATE,
   GDC_RESTORE_STATE,
   GDC_STAT_HTRACE,
   GDC_STAT_VTRACE,
   GDC_SET_PAL,
   GDC_GET_PAL,
   GDC_SET_WIDTH,
   GDC_GET_WIDTH,
   GDC_SET_FOCUS,
   GDC_GET_FOCUS,
   GDC_SET_BANK,
   GDC_GET_RGB_BITMASK,
   GDC_DEVICE_FUNCS
};

#ifdef __cplusplus
};
#endif

// $Header: x:/prj/tech/libsrc/dev2d/RCS/grd.h 1.9 1998/03/26 10:40:26 KEVIN Exp $
// Global data.

#ifdef __cplusplus
extern "C" {
#endif
extern int gdd_active;

extern grs_sys_info grd_info;
extern int grd_mode;
extern grs_drvcap grd_mode_cap;
extern grs_drvcap *grd_cap;

extern int grd_valloc_mode;
extern int grd_screen_row;
extern int grd_screen_bmt;
extern int grd_screen_max_height;

extern grs_screen *grd_screen;
extern grs_canvas *grd_screen_canvas;
extern grs_canvas *grd_visible_canvas;
extern grs_canvas *grd_back_canvas;

extern uchar **tluc8tab;

extern grs_canvas *grd_canvas;

extern void (**grd_device_table)();

extern void (**gdd_flat8_canvas_table)();
extern void (**gdd_flat16_canvas_table)();
extern void (**gdd_flat24_canvas_table)();
extern void (**gdd_bank8_canvas_table)();
extern void (**gdd_bank16_canvas_table)();
extern void (**gdd_bank24_canvas_table)();
extern void (**gdd_modex_canvas_table)();
extern void (**gdd_dispdev_canvas_table)();

extern void (**gdd_canvas_table)();

extern grs_context grd_defgc;

#define grd_bm (grd_canvas->bm)
#define grd_gc (grd_canvas->gc)
#define grd_ytab (grd_canvas->ytab)
#define grd_int_clip (grd_gc.clip.i)
#define grd_fix_clip (grd_gc.clip.f)
#define grd_clip (grd_int_clip)

extern uchar *grd_pal;
extern uchar *grd_ipal;
extern grs_rgb *grd_bpal;

extern ushort **grd_ltab816_list;
extern ushort *grd_ltab816;
extern uchar *grd_light_table;
extern int grd_light_table_size;
extern uchar *grd_unpack_buf;
extern uint grd_unpack_buf_size;
extern void *pixpal;
extern uint grd_chroma_key;
extern int (*gdd_detect_func)(grs_sys_info *info);

#ifdef __cplusplus
};
#endif

// $Header: x:/prj/tech/libsrc/dev2d/RCS/context.h 1.8 1997/01/27 11:20:25 KEVIN Exp $

#ifdef __cplusplus
extern "C" {
#endif

#define gr_min(x,y) ((x) < (y) ? (x) : (y))
#define gr_max(x,y) ((x) > (y) ? (x) : (y))

#define gr_init_gc(c) \
do {                                               \
   grs_canvas *__c = (c);                          \
   __c->gc=grd_defgc;                              \
   __c->gc.safe_clip.f.right=fix_make(__c->bm.w,0);\
   __c->gc.safe_clip.f.bot  =fix_make(__c->bm.h,0);\
   __c->gc.clip = __c->gc.safe_clip;               \
} while (0)

/* macros for setting the clipping region of a specified canvas. */
extern void gr_cset_fix_cliprect(grs_canvas* c, fix l, fix t, fix r, fix b);

#define gr_cset_cliprect(c, l, t, r, b) \
      gr_cset_fix_cliprect(c,fix_make(l,0),fix_make(t,0),fix_make(r,0),fix_make(b,0))

#define gr_set_cliprect(l, t, r, b) \
         gr_cset_cliprect(grd_canvas,l,t,r,b)

#define gr_set_fix_cliprect(l, t, r, b) \
         gr_cset_fix_cliprect(grd_canvas,l,t,r,b)

extern void gr_safe_cset_fix_cliprect(grs_canvas* c, fix l, fix t, fix r, fix b);

#define gr_safe_cset_cliprect(canv, l, t, r, b)        \
      gr_safe_cset_fix_cliprect(canv,fix_make(l,0),fix_make(t,0),fix_make(r,0),fix_make(b,0))

#define gr_safe_set_cliprect(l, t, r, b) \
      gr_safe_cset_cliprect(grd_canvas,l,t,r,b)

#define gr_safe_set_fix_cliprect(l, t, r, b) \
      gr_safe_cset_fix_cliprect(grd_canvas,l,t,r,b)

#define gr_init_fix_clip(clip, l, t, r, b)                \
   (clip)->f.sten=NULL, \
   (clip)->f.left=(l), (clip)->f.top=(t), \
   (clip)->f.right=(r),(clip)->f.bot=(b)

#define gr_set_clipmask(t,b,mask) \
   grd_clip.top=(t), grd_clip.bot=(b), \
   grd_clip.sten = (mask)

/* macros for getting parts of the graphic context of the current canvas. */
#define gr_set_fcolor(color) (grd_canvas->gc.fcolor=color)
#define gr_set_fcolor8(col8) \
do {                               \
   switch (grd_bm.type) {          \
   case BMT_FLAT16:                \
   case BMT_BANK16:                \
      gr_set_fcolor(               \
         ((ushort *)pixpal)[col8]);\
      break;                       \
   default:                        \
      gr_set_fcolor(col8);         \
      break;                       \
   }                               \
} while (0)
#define gr_get_fcolor() (grd_canvas->gc.fcolor)
#define gr_set_bcolor(color) (grd_canvas->gc.bcolor=color)
#define gr_get_bcolor() (grd_canvas->gc.bcolor)
#define gr_set_text_attr(attr) (grd_canvas->gc.text_attr=attr)
#define gr_get_text_attr() (grd_canvas->gc.text_attr)

#define gr_set_fill_type(_ft) (grd_canvas->gc.fill_type = _ft)
#define gr_get_fill_type() (grd_canvas->gc.fill_type)

#define gr_set_fill_parm(parm) \
   (grd_canvas->gc.fill_parm=(long)(parm))
#define gr_get_fill_parm() (grd_canvas->gc.fill_parm)

#define gr_cset_clipmask(canvas,t,b,mask) \
   (canvas)->gc.clip.i.top=(t), (canvas)->gc.clip.i.bot=(b), \
   (canvas)->gc.clip.i.sten = (mask)
#define gr_cset_fcolor(canvas,color) ((canvas)->gc.fcolor=color)
#define gr_cget_fcolor(canvas) ((canvas)->gc.fcolor)
#define gr_cset_bcolor(canvas,color) ((canvas)->gc.bcolor=color)
#define gr_cget_bcolor(canvas) ((canvas)->gc.bcolor)
#define gr_cset_font(canvas,fnt) ((canvas)->gc.font=fnt)
#define gr_cget_font(canvas) ((canvas)->gc.font)

/* macros for getting part of the clipping region of the current canvas. */
#define gr_get_cliprect(l,t,r,b) (*(l)=grd_clip.left,*(t)=grd_clip.top, \
   *(r)=grd_clip.right,*(b)=grd_clip.bot)
#define gr_get_fix_cliprect(l,t,r,b) (*(l)=grd_fix_clip.left, \
   *(t)=grd_fix_clip.top,*(r)=grd_fix_clip.right,*(b)=grd_fix_clip.bot)
#define gr_get_clip_l() (grd_clip.left)
#define gr_get_clip_t() (grd_clip.top)
#define gr_get_clip_r() (grd_clip.right)
#define gr_get_clip_b() (grd_clip.bot)
#define gr_get_fclip_l() (grd_fix_clip.left)
#define gr_get_fclip_t() (grd_fix_clip.top)
#define gr_get_fclip_r() (grd_fix_clip.right)
#define gr_get_fclip_b() (grd_fix_clip.bot)

/* How about some handy macros to save and restore a cliprect */
#define gr_save_cliprect(save)  *(save) = grd_clip
#define gr_restore_cliprect(save)  grd_clip = *(save)

/* macros for getting part of the clipping region of a specified canvas. */
#define gr_cget_cliprect(c,l,t,r,b) (\
   *(l)=(c)->gc.clip.i.left,*(t)=(c)->gc.clip.i.top,\
   *(r)=(c)->gc.clip.i.right,*(b)=(c)->gc.clip.i.bot)
#define gr_cget_fix_cliprect(l,t,r,b) (\
   *(l)=(c)->gc.clip.f.left,*(t)=(c)->gc.clip.f.top,\
   *(r)=(c)->gc.clip.f.right,*(b)=(c)->gc.clip.f.bot)
#define gr_cget_clip_l(c) ((c)->gc.clip.i.left)
#define gr_cget_clip_t(c) ((c)->gc.clip.i.top)
#define gr_cget_clip_r(c) ((c)->gc.clip.i.right)
#define gr_cget_clip_b(c) ((c)->gc.clip.i.bot)
#define gr_cget_fclip_l(c) ((c)->gc.clip.f.left)
#define gr_cget_fclip_t(c) ((c)->gc.clip.f.top)
#define gr_cget_fclip_r(c) ((c)->gc.clip.f.right)
#define gr_cget_fclip_b(c) ((c)->gc.clip.f.bot)

#define gr_set_unpack_buf(buf) (grd_unpack_buf = (buf))
#define gr_get_unpack_buf() (grd_unpack_buf)
#define gr_set_unpack_buf_size(buf_size) (grd_unpack_buf_size = (buf_size))
#define gr_get_unpack_buf_size() (grd_unpack_buf_size)
#define gr_set_light_tab(ltab) (grd_light_table = (ltab))
#define gr_get_light_tab() (grd_light_table)
#define gr_set_light_tab_size(ltab_size) (grd_light_table_size = (ltab_size))
#define gr_get_light_tab_size() (grd_light_table_size)

#ifdef __cplusplus
};
#endif

/*
 * $Source: s:/prj/tech/libsrc/dev2d/RCS/bmftype.h $
 * $Revision: 1.1 $
 * $Author: KEVIN $
 * $Date: 1996/04/10 16:50:36 $
 *
 * Constants for bitmap flags & type fields; prototypes for bitmap
 * functions.
 *
 * This file is part of the dev2d library.
 *
 */

#ifdef __cplusplus
extern "C" {
#endif

typedef void (gdubm_func)(grs_bitmap *bm, int x, int y);
typedef gdubm_func *gdubm_func_p;
typedef gdubm_func_p (gdubm_expose_func)(grs_bitmap *bm, int x, int y);

typedef int (gdbm_func)(grs_bitmap *bm, int x, int y, int code, gdubm_func *ubm_func);

#ifdef __cplusplus
};
#endif

/*
 * $Source: s:/prj/tech/libsrc/dev2d/RCS/linftype.h $
 * $Revision: 1.1 $
 * $Author: KEVIN $
 * $Date: 1996/04/10 16:59:01 $
 *
 * Constants for bitmap flags & type fields; prototypes for bitmap
 * functions.
 *
 * This file is part of the dev2d library.
 *
 */

#ifdef __cplusplus
extern "C" {
#endif

typedef void (gdulin_func)(int x, int y, int c1);
typedef gdulin_func *gdulin_func_p;
typedef gdulin_func_p (gdulin_expose_func)(int x, int y, int c1);

#ifdef __cplusplus
};
#endif

/*
 * $Source: s:/prj/tech/libsrc/dev2d/RCS/pixftype.h $
 * $Revision: 1.1 $
 * $Author: KEVIN $
 * $Date: 1996/04/10 16:59:50 $
 *
 * Constants for bitmap flags & type fields; prototypes for bitmap
 * functions.
 *
 * This file is part of the dev2d library.
 *
 */

#ifdef __cplusplus
extern "C" {
#endif

typedef void (gdupix_func)(int c, int x, int y);
typedef gdupix_func *gdupix_func_p;
typedef gdupix_func_p (gdupix_expose_func)(int c, int x, int y);

typedef int (gdgpix_func)(int x, int y);
typedef gdgpix_func *gdgpix_func_p;
typedef gdgpix_func_p (gdgpix_expose_func)(int x, int y);

typedef int (gdlpix_func)(fix i, int c);
typedef gdlpix_func *gdlpix_func_p;
typedef gdlpix_func_p (gdlpix_expose_func)(fix i, int c);

#ifdef __cplusplus
};
#endif

/*
 * $Source: x:/prj/tech/libsrc/dev2d/RCS/gdbm.h $
 * $Revision: 1.4 $
 * $Author: TOML $
 * $Date: 1996/10/16 16:06:50 $
 *
 * Bitmap blitting prototypes, constants and macros.
 *
 * This file is part of the dev2d library.
 */

#ifdef __cplusplus
extern "C" {
#endif

#define gd_ubitmap \
   ((gdubm_func *)(gdd_canvas_table[GDC_UBITMAP]))

#define gd_ubitmap_expose \
   ((gdubm_expose_func *)(gdd_canvas_table[GDC_UBITMAP_EXPOSE]))

extern int gd_bitmap(grs_bitmap *bm, int x, int y);
extern int gd_bitmap_opt(grs_bitmap *bm, int x, int y, gdubm_func *ubm_func);

extern void gd_get_bitmap(grs_bitmap *bm, int x, int y);

extern void gd_hflip_in_place(grs_bitmap *bm);

extern int gd_rsd8_convert(grs_bitmap *sbm, grs_bitmap *dbm);

extern uchar *gd_rsd8_unpack(uchar* src, uchar *dst);

enum {
   GR_UNPACK_RSD8_OK,
   GR_UNPACK_RSD8_NOBUF,
   GR_UNPACK_RSD8_NOTRSD,
};

#ifdef __cplusplus
};
#endif

/*
 * $Source: s:/prj/tech/libsrc/dev2d/RCS/gdlin.h $
 * $Revision: 1.1 $
 * $Author: KEVIN $
 * $Date: 1996/04/10 16:37:26 $
 *
 * Global stuff.
 *
 * This file is part of the dev2d library.
 */

#ifdef __cplusplus
extern "C" {
#endif

#define gd_uhline \
   ((gdulin_func *)(gdd_canvas_table[GDC_UHLINE]))

#define gd_uvline \
   ((gdulin_func *)(gdd_canvas_table[GDC_UVLINE]))

#define gd_uhline_expose \
   ((gdulin_expose_func *)(gdd_canvas_table[GDC_UHLINE_EXPOSE]))

#define gd_uvline_expose \
   ((gdulin_expose_func *)(gdd_canvas_table[GDC_UVLINE_EXPOSE]))

extern int gd_hline(int x, int y, int x1);
extern int gd_hline_opt(int x, int y, int x1, gdulin_func *uhlin_func);
extern int gd_vline(int x, int y, int y1);
extern int gd_vline_opt(int x, int y, int y1, gdulin_func *uvlin_func);

#ifdef __cplusplus
};
#endif

/*
 * $Source: s:/prj/tech/libsrc/dev2d/RCS/gdrect.h $
 * $Revision: 1.1 $
 * $Author: KEVIN $
 * $Date: 1996/04/10 16:37:46 $
 *
 * Global stuff.
 *
 * This file is part of the dev2d library.
 */

#ifdef __cplusplus
extern "C" {
#endif

extern void gd_urect(int x, int y, int x1, int y1);
extern int gd_rect(int x, int y, int x1, int y1);
extern void gd_ubox(int x, int y, int x1, int y1);
extern int gd_box(int x, int y, int x1, int y1);
extern void gd_clear(int c);

#ifdef __cplusplus
};
#endif

// $Header: x:/prj/tech/libsrc/dev2d/RCS/gdpix.h 1.3 1997/02/17 14:49:48 KEVIN Exp $

#ifdef __cplusplus
extern "C" {
#endif

#define gd_upix \
   ((gdupix_func *)(gdd_canvas_table[GDC_UPIX]))
#define gd_upix8 \
   ((gdupix_func *)(gdd_canvas_table[GDC_UPIX8]))
#define gd_upix16 \
   ((gdupix_func *)(gdd_canvas_table[GDC_UPIX16]))
#define gd_upix24 \
   ((gdupix_func *)(gdd_canvas_table[GDC_UPIX24]))

#define gd_upix_expose \
   ((gdupix_expose_func *)(gdd_canvas_table[GDC_UPIX_EXPOSE]))
#define gd_upix8_expose \
   ((gdupix_expose_func *)(gdd_canvas_table[GDC_UPIX8_EXPOSE]))
#define gd_upix16_expose \
   ((gdupix_expose_func *)(gdd_canvas_table[GDC_UPIX16_EXPOSE]))
#define gd_upix24_expose \
   ((gdupix_expose_func *)(gdd_canvas_table[GDC_UPIX24_EXPOSE]))

extern void gd_upoint(int x, int y);
extern void gd_upoint_opt(int x, int y, gdupix_func *upix_func);

extern int gd_pix_opt(int c, int x, int y, gdupix_func *upix_func);
extern int gd_pix8(int c, int x, int y);
extern int gd_pix16(int c, int x, int y);
extern int gd_pix24(int c, int x, int y);
extern int gd_point(int x, int y);

#define gd_ugpix8 \
   ((gdgpix_func *)(gdd_canvas_table[GDC_UGPIX8]))
#define gd_ugpix16 \
   ((gdgpix_func *)(gdd_canvas_table[GDC_UGPIX16]))
#define gd_ugpix24 \
   ((gdgpix_func *)(gdd_canvas_table[GDC_UGPIX24]))

#define gd_ugpix8_expose \
   ((gdgpix_expose_func *)(gdd_canvas_table[GDC_UGPIX8_EXPOSE]))
#define gd_ugpix16_expose \
   ((gdgpix_expose_func *)(gdd_canvas_table[GDC_UGPIX16_EXPOSE]))
#define gd_ugpix24_expose \
   ((gdgpix_expose_func *)(gdd_canvas_table[GDC_UGPIX24_EXPOSE]))

extern int gr_get_pixel_bm(grs_bitmap *bm, int x, int y);
extern int gd_gpix_opt(int x, int y, gdgpix_func *ugpix_func);
extern int gd_gpix8(int x, int y);
extern int gd_gpix16(int x, int y);
extern int gd_gpix24(int x, int y);

#define gd_lpix \
   ((gdlpix_func *)(gdd_canvas_table[GDC_LPIX]))
#define gd_lpix8 \
   ((gdlpix_func *)(gdd_canvas_table[GDC_LPIX8]))
#define gd_lpix16 \
   ((gdlpix_func *)(gdd_canvas_table[GDC_LPIX16]))
#define gd_lpix24 \
   ((gdlpix_func *)(gdd_canvas_table[GDC_LPIX24]))

#define gd_lpix_expose \
   ((gdlpix_expose_func *)(gdd_canvas_table[GDC_LPIX_EXPOSE]))
#define gd_lpix8_expose \
   ((gdlpix_expose_func *)(gdd_canvas_table[GDC_LPIX8_EXPOSE]))
#define gd_lpix16_expose \
   ((gdlpix_expose_func *)(gdd_canvas_table[GDC_LPIX16_EXPOSE]))
#define gd_lpix24_expose \
   ((gdlpix_expose_func *)(gdd_canvas_table[GDC_LPIX24_EXPOSE]))

#ifdef __cplusplus
};
#endif

// $Header: x:/prj/tech/libsrc/dev2d/RCS/grdev.h 1.3 1998/03/12 10:40:48 KEVIN Exp $
// Macros for table driven device driver functions.

#ifdef __cplusplus
extern "C" {
#endif

/* here are the definitions for all the table driven function. */
#define gr_init_device \
   ((int (*)(grs_sys_info *_info))grd_device_table[GDC_INIT_DEVICE])

#define gr_close_device \
   ((int (*)(grs_sys_info *_info))grd_device_table[GDC_CLOSE_DEVICE])

#define gr_set_screen_mode \
   ((int (*)(int mode, int clear))grd_device_table[GDC_SET_MODE])

#define gr_get_screen_mode \
   ((int (*)(void))grd_device_table[GDC_GET_MODE])

#define gr_save_state \
   ((int (*)(VideoState *vidStatePtr))grd_device_table[GDC_SAVE_STATE])

#define gr_restore_state \
   ((int (*)(VideoState *vidStatePtr))grd_device_table[GDC_RESTORE_STATE])

#define gr_stat_htrace \
   ((int (*)(void))grd_device_table[GDC_STAT_HTRACE])

#define gr_stat_vtrace \
   ((int (*)(void))grd_device_table[GDC_STAT_VTRACE])

#define gr_set_screen_pal \
   ((void (*)(int start,int n,uchar *pal_data))grd_device_table[GDC_SET_PAL])

#define gr_get_screen_pal \
   ((void (*)(int start,int n,uchar *pal_data))grd_device_table[GDC_GET_PAL])

#define gr_set_width \
   ((int (*)(int w))grd_device_table[GDC_SET_WIDTH])

#define gr_get_width \
   ((int (*)(void))grd_device_table[GDC_GET_WIDTH])

#define gr_set_focus \
   ((void (*)(int x,int y))grd_device_table[GDC_SET_FOCUS])

#define gr_get_focus \
   ((void (*)(int *x,int *y))grd_device_table[GDC_GET_FOCUS])

#define gr_get_screen_rgb_bitmask \
   ((void (*)(grs_rgb_bitmask *bitmask))grd_device_table[GDC_GET_RGB_BITMASK])

#ifdef __cplusplus
};
#endif

// $Header: x:/prj/tech/libsrc/dev2d/RCS/pal.h 1.3 1998/01/27 16:40:17 JAEMZ Exp $
// Prototypes and macros for palette manipulation routines.

#ifdef __cplusplus
extern "C" {
#endif

extern void gr_set_pal (int start, int n, uchar *pal_data);
extern void gr_get_pal (int start, int n, uchar *pal_data);
extern void gr_blend_pal (fix degree, ulong color, int start,
                           int n, uchar *old_pal, uchar *new_pal);
extern void gr_bw_pal (fix degree, int start, int n, uchar *old_pal, uchar *new_pal);
extern void gr_set_default_pal(uchar *pal);

#ifdef __cplusplus
};
#endif

// $Header: x:/prj/tech/libsrc/dev2d/RCS/gpal.h 1.2 1998/02/13 10:25:11 JAEMZ Exp $
// Prototypes and macros for Gamma correction

#ifdef __cplusplus
extern "C" {
#endif

// Sets the the gamma auto correct state, toggles if negative
// else you should set TRUE or FALSE
extern void gr_set_gamma_auto(int correct);

// Sets the gamma value, but won't do anything if not on
extern void gr_set_gamma_value(float gamma);

// Returns whether gamma correction is on, and stuffs gamma if non-null
extern bool gr_get_gamma_state(float *gamma);

// Set a range of indices to protect or not
// start to end inclusive
// protect==TRUE mean that index will not be contrast adjusted
extern void gr_gamma_protect_range(int start,int end,bool protect);

// Set a list of indices to protect or not
extern void gr_gamma_protect_list(uchar *list,int num,bool protect);

#ifdef __cplusplus
};
#endif

// $Header: x:/prj/tech/libsrc/dev2d/RCS/cpal.h 1.2 1998/02/13 10:24:57 JAEMZ Exp $
// Prototypes and macros for Gamma correction

#ifdef __cplusplus
extern "C" {
#endif

// Sets the the gamma auto correct state, toggles if negative
// else you should set TRUE or FALSE
extern void gr_set_contrast_auto(int correct);

// Sets the contrast value, but won't do anything if not on
// About is what value to scale about, scale is the value.
extern void gr_set_contrast_value(float about,float scale);

// Returns whether contrast is on, and stuffs gamma if non-null
extern bool gr_get_contrast_state(float *about,float *scale);

// Set a range of indices to protect or not
// start to end inclusive
// protect==TRUE mean that index will not be contrast adjusted
extern void gr_contrast_protect_range(int start,int end,bool protect);

// Set a list of indices to protect or not
extern void gr_contrast_protect_list(uchar *list,int num,bool protect);

#ifdef __cplusplus
};
#endif

/*
 * $Source: x:/prj/tech/libsrc/dev2d/RCS/pal16.h $
 * $Revision: 1.4 $
 * $Author: KEVIN $
 * $Date: 1998/04/03 13:29:56 $
 *
 * Prototypes and macros for 16 bit palette manipulation routines.
 *
 * This file is part of the dev2d library.
 *
 */

#ifdef __cplusplus
extern "C" {
#endif

extern void gr_make_pal555_from_pal888(ushort *pal16, uchar *pal_data);
extern ushort *gr_alloc_pal555_from_pal888(uchar *pal_data);
extern void gr_make_pal1555_from_pal888(ushort *pal16, uchar *pal_data);
extern ushort *gr_alloc_pal1555_from_pal888(uchar *pal_data);
extern void gr_make_pal565_from_pal888(ushort *pal16, uchar *pal_data);
extern ushort *gr_alloc_pal565_from_pal888(uchar *pal_data);
extern ushort **grd_pal16_list;
extern ushort *grd_pal16;
extern uchar *grd_ipal16;
extern void gr_make_pal16(int start, int n, ushort *pal16, uchar *pal_data, grs_rgb_bitmask *bitmask);
extern void gr_set_pal16(ushort *pal, int n);
extern void gr_make_ipal1555(uchar *ipal);
extern uchar *gr_alloc_ipal1555();
extern void gr_make_ipal555(uchar *ipal);
extern uchar *gr_alloc_ipal555();
extern void gr_make_ipal565(uchar *ipal);
extern uchar *gr_alloc_ipal565();

extern void gr_compute_ltab816(ushort *ltab, uchar *pal_data, int dark_levels, int bright_levels, grs_rgb_bitmask *bitmask);

#define gr_set_default_pal16(__pal) grd_pal16 = (__pal)
#define gr_set_pal16_list(__pal_list) grd_pal16_list = (__pal_list)
#define gr_set_ipal16(__pal) grd_ipal16=(__pal)
#define GRC_OPTIMIZED_PAL16 255

#ifdef __cplusplus
};
#endif

/*
 * $Source: x:/prj/tech/libsrc/dev2d/RCS/init.h $
 * $Revision: 1.3 $
 * $Author: KEVIN $
 * $Date: 1996/08/29 09:44:38 $
 *
 * Prototypes for detection routines.
 *
 * This file is part of the dev2d library.
 *
 */

#ifdef __cplusplus
extern "C" {
#endif

extern int gd_init();
extern void gd_use_svga();
extern int gd_svga_init();

extern void gd_use_com();

extern void gd_use_no_video();
extern int gd_no_video_init();

extern void gd_use_flat();
extern int gd_flat_init();

extern void gd_use_flat8();
extern int gd_flat8_init();

extern void gd_use_flat16();
extern int gd_flat16_init();

#define dev2d_init gd_svga_init

extern void gd_release_com();

extern int gd_close();

#ifdef __cplusplus
};
#endif

/*
 * $Source: x:/prj/tech/libsrc/dev2d/RCS/tluctab.h $
 * $Revision: 1.4 $
 * $Author: KEVIN $
 * $Date: 1997/01/22 12:54:25 $
 *
 * Declarations and macros for translucency
 * table generation.
 *
 * This file is part of the dev2d library.
 *
 */

#ifndef _TLUCTAB
#define _TLUCTAB

#ifdef __cplusplus
extern "C" {
#endif

extern void gr_init_clut16_vector(ushort *clut16, int color, alpha_vector *opacity, int format);
extern void gr_init_clut16(ushort *clut16, int color, alpha_real opacity, int format);
extern void gr_init_clut565(ushort *clut16, int color, float opacity);
extern void gr_init_clut555(ushort *clut16, int color, float opacity);

extern uchar *gr_init_simple_translucency_table(uchar *p, fix opacity, grs_rgb color, uchar *pal);
extern uchar *gr_init_translucency_table(uchar *p, fix opacity, fix purity, grs_rgb color);
extern uchar *gr_init_lit_translucency_table(uchar *p, fix opacity, fix purity, grs_rgb color, grs_rgb light);
extern uchar *gr_init_lit_translucency_tables(uchar *p, fix opacity, fix purity, grs_rgb color, int n);

extern int gr_dump_tluc8_table(uchar *buf, int nlit);
extern void gr_read_tluc8_table(uchar *buf);

#define gr_alloc_translucency_table(n) \
   ((uchar *)gr_malloc(n*256))
#define gr_free_translucency_table(tab) (gr_free(tab))

#define gr_make_translucency_table(op, pu, co) \
  (gr_init_translucency_table(gr_alloc_translucency_table(1), op, pu, co))
#define gr_make_lit_translucency_table(op, pu, co, li) \
  (gr_init_translucency_table(gr_alloc_translucency_table(1), op, pu, co, li))
#define gr_make_lit_translucency_tables(op, pu, co, lnum) \
  (gr_init_lit_translucency_tables(gr_alloc_translucency_table(lnum), op, pu, co, lnum))

#define gr_make_tluc8_table(num, op, pu, co) \
   (tluc8tab[num]=gr_make_translucency_table(op, pu, co))
#define gr_make_lit_tluc8_table(num, op, pu, co, li) \
   (tluc8ltab[num]=gr_make_lit_translucency_tables(op, pu, co, li), \
    gr_make_tluc8_table(num, op, pu, co))
#define gr_alloc_tluc8_spoly_table(num) \
   (tluc8nstab=num, tluc8stab=gr_alloc_translucency_table(num))
#define gr_init_tluc8_spoly_table(num, op, pu, co, li) \
   (gr_init_lit_translucency_table(tluc8stab+(256*num), op, pu, co, li))
#define gr_init_tluc8_spoly_tables(num, op, pu, co, li) \
   (gr_init_lit_translucency_tables(tluc8stab+(256*num), op, pu, co, li))
#define gr_bind_tluc8_table(num, p) (tluc8tab[num]=p)
#define gr_bind_lit_tluc8_table(num, p) (tluc8ltab[num]=p)
#define gr_bind_tluc8_spoly_table(p) (tluc8stab=p)

#ifdef __cplusplus
};
#endif
#endif

/*
 * $Source: s:/prj/tech/libsrc/dev2d/RCS/grmalloc.h $
 * $Revision: 1.1 $
 * $Author: KEVIN $
 * $Date: 1996/04/10 16:40:10 $
 *
 * Declarations for internal memory allocation routines.
 *
 * This file is part of the dev2d library.
 */

#ifdef __cplusplus
extern "C" {
#endif

typedef void (*grs_voidvoid)(void *);
extern void gr_set_malloc (void *(*malloc_func)(int bytes));
extern void gr_set_free (grs_voidvoid);
extern void *(*gr_malloc)(int n);
extern void (*gr_free)(void *p);

#ifdef __cplusplus
};
#endif

/*
 * $Source: s:/prj/tech/libsrc/dev2d/RCS/grnull.h $
 * $Revision: 1.2 $
 * $Author: KEVIN $
 * $Date: 1996/04/30 11:57:22 $
 *
 * Null-function placeholder prototype.
 *
 * This file is part of the dev2d library.
 *
 * $Log: grnull.h $
 * Revision 1.2  1996/04/30  11:57:22  KEVIN
 * Added gr_scream(), which spews a warning when called.
 * 
 * Revision 1.1  1996/04/10  16:40:30  KEVIN
 * Initial revision
 * 
 * Revision 1.1  1993/02/04  17:36:36  kaboom
 * Initial revision
 * 
 */

#ifdef __cplusplus
extern "C" {
#endif

extern void gr_null (void);
extern void gr_scream (void);
#define gr_warn gr_scream

#ifdef __cplusplus
};
#endif

/*
 * $Source: s:/prj/tech/libsrc/dev2d/RCS/indexmac.h $
 * $Revision: 1.1 $
 * $Author: KEVIN $
 * $Date: 1996/04/10 16:55:36 $
 *
 * Constants for bitmap flags & type fields; prototypes for bitmap
 * functions.
 *
 * This file is part of the dev2d library.
 *
 */

#ifdef __cplusplus
extern "C" {
#endif

#define make_index_bmt_fill_bmf(bm) \
   ((bm->type*FILL_TYPES + grd_gc.fill_type)*BMF_TYPES + (bm->flags&1))

#define make_index_bmt_bmf(bm) \
   bm->type*BMF_TYPES + (bm->flags&1)

#define make_index_bmt(bm) \
   bm->type

#ifdef __cplusplus
};
#endif

#ifdef __cplusplus
extern "C" {
#endif

#define gr_bitmap gd_bitmap
#define gr_hflip_in_place gd_hflip_in_place
#define gr_mono_bitmap gd_bitmap
#define gr_flat8_bitmap gd_bitmap
#define gr_rsd8_bitmap gd_bitmap
#define gr_mask_bitmap(bm, s, x, y) \
        gd_bitmap(bm, x, y)
#define gr_ubitmap gd_ubitmap
#define gr_mono_ubitmap gd_ubitmap
#define gr_flat8_ubitmap gd_ubitmap
#define gr_rsd8_ubitmap gd_ubitmap
#define gr_mask_ubitmap(bm, s, x, y) \
        gd_ubitmap(bm, x, y)
#define gr_get_bitmap gd_get_bitmap
#define gr_rsd8_convert gd_rsd8_convert
#define gr_rsd8_unpack gd_rsd8_unpack

#define gr_clut_bitmap(bm, x, y, clut) \
do {                                       \
   if (gr_get_fill_type() == FILL_NORM) {  \
      ulong fill_save=gr_get_fill_parm();  \
      gr_set_fill_type(FILL_CLUT);         \
      gr_set_fill_parm(clut);              \
      gd_bitmap(bm, x, y);                 \
      gr_set_fill_type(FILL_NORM);         \
      gr_set_fill_parm(fill_save);         \
   } else {                                \
      gd_bitmap(bm, x, y);                 \
   }                                       \
} while(0)
#define gr_clut_ubitmap(bm, x, y, clut) \
do {                                       \
   if (gr_get_fill_type() == FILL_NORM) {  \
      ulong fill_save=gr_get_fill_parm();  \
      gr_set_fill_type(FILL_CLUT);         \
      gr_set_fill_parm(clut);              \
      gd_ubitmap(bm, x, y);                \
      gr_set_fill_type(FILL_NORM);         \
      gr_set_fill_parm(fill_save);         \
   } else {                                \
      gd_ubitmap(bm, x, y);                \
   }                                       \
} while(0)

#define gr_hline gd_hline
#define gr_vline gd_vline
#define gr_uhline gd_uhline
#define gr_uvline gd_uvline

#define gr_box gd_box
#define gr_ubox gd_ubox
#define gr_rect gd_rect
#define gr_urect gd_urect
#define gr_clear gd_clear
#define dr_scr_canv grd_screen_canvas
#define grd_scr_canv grd_screen_canvas

#define gr_fill_pixel gd_pix8
#define gr_set_pixel gd_pix8
#define gr_fill_upixel gd_upix8
#define gr_set_upixel gd_upix8
#define gr_get_pixel gd_gpix8
#define gr_get_upixel gd_ugpix8
#define gr_point gd_point
#define gr_upoint gd_upoint

#define gr_double_h_ubitmap gr_ubitmap
#define gr_double_hv_ubitmap gr_ubitmap

#ifdef __cplusplus
};
#endif

/*
 * $Source: s:/prj/tech/libsrc/dev2d/RCS/rgb.h $
 * $Revision: 1.1 $
 * $Author: KEVIN $
 * $Date: 1996/04/10 17:00:00 $
 *
 * Prototypes and macros for rgb manipulation routines.
 *
 * This file is part of the dev2d library.
 *
 */

#ifdef __cplusplus
extern "C" {
#endif

#define RGB_OK (0)
#define RGB_OUT_OF_MEMORY (-1)
#define RGB_CANT_DEALLOCATE (-2)
#define RGB_IPAL_NOT_ALLOCATED (-3)

/* convert fixed-point (r,g,b) triplet into a 15-bit ipal index. */
#define gr_index_rgb(r,g,b) \
   (((r)>>19)&0x1f) | (((g)>>14)&0x3e0) | (((b)>>9)&0x7c00)

/* convert an 8-8-8 long rgb into a 15-bit ipal index. */
#define gr_index_lrgb(t) \
   ((((t)>>3)&0x1f) | (((t)>>6)&0x3e0) | (((t)>>9)&0x7c00))

/* convert 8-bit r,g,b into grs_rgb format. */
#define gr_bind_rgb(r,g,b) (((r)<<2)|((g)<<13)|((b)<<24))

/* convert a grs_rgb value into a 15-bit inverse palette table index. */
#define gr_index_brgb(c) \
   ((((c)>>5)&0x1f)|(((c)>>11)&0x3e0)|(((c)>>17)&0x7c00))

/* split a grs_rgb into its component 8-bit r, g, and b values. */
#define gr_split_rgb(c, r, g, b) \
do {                       \
   *(r) = ((c)>>2)&0xff;   \
   *(g) = ((c)>>13)&0xff;  \
   *(b) = ((c)>>24)&0xff;  \
} while (0)

/* Generate an inverse palette for the given screen palette */
int gr_alloc_ipal(void);

/* Reinitialize the ipal for the current palette */
int gr_init_ipal(void);

/* Calculate an ipal for any given palette */
int gr_calc_ipal(grs_rgb *bpal, uchar *ipal);

/* Destroy the current inverse palette, freeing memory */
int gr_free_ipal(void);

#ifdef __cplusplus
};
#endif

// $Header: x:/prj/tech/libsrc/dev2d/RCS/blnfcn.h 1.2 1996/12/06 15:29:46 KEVIN Exp $
// prototypes for blending routines.

#ifdef __cplusplus
extern "C" {
#endif

extern uint gr_blend_color(uint c0, uint c1, alpha_real alpha, int format);
extern uint gr_blend_color_vector(uint c0, uint c1, alpha_vector alpha, int format);

extern void gr_blend_pal16(ushort *dst, ushort *src, uint color, alpha_real alpha, int format);
extern void gr_blend_pal16_vector(ushort *dst, ushort *src, uint color, alpha_vector alpha, int format);

#ifdef __cplusplus
};
#endif

// $Header: x:/prj/tech/libsrc/dev2d/RCS/rsdcfg.h 1.1 1997/03/11 10:44:14 KEVIN Exp $

#ifdef __cplusplus
extern "C" {
#endif

#define RCF_ALLOCATE 1

typedef struct gds_rsd_config {
   uchar *buf;
   int size, cap, flags;
} gds_rsd_config;

extern void gd_set_rsd_config(gds_rsd_config *cfg);
extern void gd_get_rsd_config(gds_rsd_config *cfg);

#ifdef __cplusplus
};
#endif

// $Header: x:/prj/tech/libsrc/dev2d/RCS/fcolor.h 1.2 1998/04/01 11:17:56 KEVIN Exp $

// get an fcolor appropriate for the current screen mode given an 888rgb (red low)
// needs an ipal to work in 8 bit modes.

EXTERN int gr_make_screen_fcolor(int lrgb);

#endif /* __DEV2D_H */ 
