/* This File Automatically Generated by the build system */ 
#include <matrix.h>
#include <r3ds.h> 
#ifndef __R3D_H 
#define  __R3D_H 
#pragma once 
/*
 * $Source: x:/prj/tech/libsrc/r3d/RCS/xfrmtab.h $
 * $Revision: 1.6 $
 * $Author: JAEMZ $
 * $Date: 1998/06/18 11:27:33 $
 *
 * Transform and projection definitions
 *
 */

typedef struct _r3s_xform_tab {
   void (*rotate_block)(int n,r3s_point dst[],mxs_vector src[]);
   void (*project_block)(int n,r3s_point p[]);
   void (*transform_block)(int n,r3s_point dst[],mxs_vector src[]);
} r3s_xform_tab;

EXTERN r3s_xform_tab *r3d_xform_ftabs[];

// $Header: x:/prj/tech/libsrc/r3d/RCS/xform.h 1.9 1998/06/18 11:27:29 JAEMZ Exp $
// Transform and projection definitions

// define to dereference global f pointer
#define R3_XFORM(x) (*((r3d_glob.xform_tab).x))

// The basic set of transformers and projectors are as follows.  The
// project class of functions just projects, stuffing the sx,sy, and w
// values into the 2d part of the point.  The rotate class of functions
// just

// some of these will be function pointers
EXTERN void r3_transform_block(int n,r3s_point dst[],mxs_vector src[]);
#define r3_rotate_block(n,dst,src) (R3_XFORM(rotate_block)((n),(dst),(src)))
#define r3_project_block(n,p) (R3_XFORM(project_block)((n),(p)))
#define r3_transform_block_func R3_XFORM(transform_block)

EXTERN void r3_transform_list(int n,r3s_phandle dst[],mxs_vector *src[]);
EXTERN void r3_rotate_list(int n,r3s_phandle dst[],mxs_vector *src[]);
EXTERN void r3_project_list(int n,r3s_phandle p[]);

#define r3_transform_point(dst,src) r3_transform_block(1,(dst),(src))
#define r3_rotate_point(dst,src) (R3_XFORM(rotate_block)(1,(dst),(src)))
#define r3_project_point(p) (R3_XFORM(project_block)(1,(p)))

// This is the preferred model, especially since every tile renderer is
// fixed anyway it gets you the delta to add to your transformed points. 
// It stuffs the delta into dst.

EXTERN void r3_get_delta(mxs_vector *dst,mxs_vector *src);
EXTERN void r3_copy_add_delta(r3s_point *dst,r3s_point *src,mxs_vector *delta);

// $Header: x:/prj/tech/libsrc/r3d/RCS/clip.h 1.13 1998/06/18 11:25:48 JAEMZ Exp $

typedef enum {
   R3_INSIDE=0,
   R3_OUTSIDE=1,
   R3_CROSSES=2
} r3e_clipinfo;

typedef enum {
   R3_CLIP,        // do all clipping
   R3_NO_CLIP,     // do no clipping
   R3_USER_CLIP    // don't view clip, but do user clipping
} r3e_clipmode;

EXTERN void r3_set_clipmode(r3e_clipmode e);
EXTERN r3e_clipmode r3_get_clipmode();
EXTERN void r3_set_clip_flags(int flags);
EXTERN void r3_set_near_plane(mxs_real dist);
EXTERN mxs_real r3_get_near_plane();

// force recalculation of internal clip state
EXTERN void r3_set_clip(void);

EXTERN void r3_std_code_points(int n, r3s_point *src);

// $Header: x:/prj/tech/libsrc/r3d/RCS/clipcon.h 1.8 1998/06/30 18:45:55 buzzard Exp $

typedef struct {
   void *clip_data;
   mxs_plane world_clip[5];
   int   num_user_planes;
   int   max_user_planes;
   int   clip_flags;   // which u,v coordinate type stuff to clip
   mxs_real  near_plane;   // in view space
   r3e_clipmode clip_mode;
} r3s_clip_context;

#define R3_CLIP_I      1
#define R3_CLIP_U      2
#define R3_CLIP_V      4
#define R3_CLIP_UV     6
#define R3_CLIP_ALL    7
#define R3_CLIP_RGB    (1+8+16)   // store RGB as I,*,*,H,D

// $Header: x:/prj/tech/libsrc/r3d/RCS/clipplan.h 1.3 1998/06/18 11:25:49 JAEMZ Exp $

EXTERN void r3_clear_clip_planes(void);
EXTERN void r3_pop_clip_plane(void);
EXTERN void r3_push_clip_plane(mxs_plane *p);

// $Header: x:/prj/tech/libsrc/r3d/RCS/clipprim.h 1.10 1998/06/18 11:25:50 JAEMZ Exp $   Internal clipping of primitives

#ifndef _CLIPPRIM_H
#define _CLIPPRIM_H

// clip a polygon against the active clip planes
EXTERN int r3_clip_polygon(int n,r3s_phandle *src,r3s_phandle **dest);

// generate an or'd together clipcode of the polygon.
// r3d_ccodes_or & r3d_ccodes_and are updated as well; see below
EXTERN int r3_code_polygon(int n, r3s_phandle *src);

// clip a polygon against the view planes regardless of clip mode
EXTERN int r3_raw_clip_polygon(int n,r3s_phandle *src,r3s_phandle **dest);

// clip a line against the view planes
EXTERN bool r3_clip_line(r3s_phandle *src, r3s_phandle **dest);

// The following values are stuffed, but never cleared, in
// certain cases.  Basically, the user clears them, calls
// one or more functions that cumulatively stuffs them, then
// does whatever with the result.

EXTERN ulong r3d_ccodes_or, r3d_ccodes_and;
// Here are the functions that stuff them:
//
//  r3_ccodes_or:
//     r3_transform_block() in project space only
//     r3_code_polygon()
//    *r3_block_or 
//    *r3_block_or_and
//
//  r3_ccodes_and:
//     r3_code_polygon()
//    *r3_block_and
//    *r3_block_or_and
//
//  Functions marked [*] aren't written yet.

// This routine clips a bounding box in world space. 
// It returns the and_ccode of all the clip codes and
// stuffs the or_code.  Since it returns and_ccode you can use it as a
// branch for trivial reject if non-zero.  
EXTERN int r3_clip_bbox(mxs_vector *bmin,mxs_vector *bmax,int *or_code);

// This routine clips a bouding sphere in world space.
// It returns the and_ccode of all the clip codes and
// stuffs the or_code.  Since it returns and_ccode you can use it as a
// branch for trivial reject if non-zero.  
EXTERN int r3_clip_sphere(mxs_vector *cen,float rad,int *or_code);

// This routine clip codes a point in world space.
// It returns the code
EXTERN int r3_clip_point(mxs_vector *cen);

// why is this here?
EXTERN void r3_compute_camera_planes(void);

#endif

// $Header: x:/prj/tech/libsrc/r3d/RCS/primcon.h 1.5 1996/06/06 19:08:43 JAEMZ Exp $

typedef struct
{
   ulong color;

   r3s_texture bm;    // default texture if poly

      // flags which indicate what function we use
   uchar clip_2d;

   uchar point_flags;
   uchar line_flags;
   uchar poly_flags;

   uchar bm_type;  // plus transparency flag
} r3s_prim_context;

// $Header: x:/prj/tech/libsrc/r3d/RCS/prim.h 1.12 1998/06/30 18:45:54 buzzard Exp $

EXTERN void r3_set_2d_clip(bool context);
EXTERN void r3_set_color(int color);
EXTERN void r3_set_point_context(int context);
EXTERN void r3_set_line_context(int context);
EXTERN void r3_set_polygon_context(int context);
EXTERN void r3_set_texture(r3s_texture id);
EXTERN void r3_force_texture(r3s_texture id);

// force recalculation of all internal primitve state
EXTERN void r3_set_prim(void);

EXTERN int r3_draw_point(r3s_phandle p);
EXTERN int r3_draw_line(r3s_phandle p0,r3s_phandle p1);
EXTERN int r3_bitmap (r3s_texture bm, r3s_phandle p);

#define r3_draw_poly     (r3d_glob.prim_tab.draw_3d_poly)
#define r3_draw_tmap     (r3d_glob.prim_tab.draw_3d_tmap)
EXTERN BOOL r3d_do_setup;

// flags for draw_point context
#define R3_PT_TRANSLUCENT 1
#define R3_PT_ANTI_ALIAS  2

// flags for draw_line context
#define R3_LN_FLAT             0
#define R3_LN_RGB_GOURAUD      1
#define R3_LN_CLUT_GOURUAD     2
#define R3_LN_PALETTE_GOURAUD  3

// flags for polygon drawing

   // primary drawing mode
#define R3_PL_POLYGON          0
#define R3_PL_TRISTRIP         1
#define R3_PL_TRIFAN           2
#define R3_PL_QUADSTRIP        3

   // lighting mode
#define R3_PL_UNLIT            0
#define R3_PL_GOURAUD          4
#define R3_PL_RGB_GOURAUD      8
#define R3_PL_PALETTE_GOURAUD  12

   // fill modes
#define R3_PL_SOLID             0
#define R3_PL_TRANSLUCENT      16
#define R3_PL_TEXTURE          32
#define R3_PL_TEXTURE_LINEAR   48

   // outline in wireframe as well as draw normally
#define R3_PL_WIRE             64

   // check facing using vertices
#define R3_PL_CHECK_FACING     128

#define R3_PL_MODE_MASK         3
#define R3_PL_LIGHT_MASK       12
#define R3_PL_TEXTURE_MASK     48

// $Header: x:/prj/tech/libsrc/r3d/RCS/primtab.h 1.7 1997/10/03 13:03:29 KEVIN Exp $

// primitive function table type

typedef struct grs_vertex grs_vertex;

typedef struct {
   int (*draw_3d_poly) (int n, r3s_phandle *vp);
   int (*draw_3d_tmap) (int n, r3s_phandle *vp, r3s_texture bm);
   int (*draw_2d_poly) (int n, r3s_phandle *vp);
   void (*draw_2d_tmap) (r3s_texture bm); // actually, just setup
   int (*draw_2d_line) (r3s_phandle p0, r3s_phandle p1);
   int (*draw_2d_point)(r3s_phandle p0);
} r3s_prim_tab;

// $Header: x:/prj/tech/libsrc/r3d/RCS/primface.h 1.4 1998/06/18 11:26:51 JAEMZ Exp $

   // check three pts to see if forward facing
EXTERN bool r3_check_facing_3(r3s_phandle *vp);

   // find first 3 non-colinear points and check if forward facing
EXTERN bool r3_check_facing_n(int n, r3s_phandle *vp);

   // check viewspace pt & normal to see if forward facing
EXTERN bool r3_check_v_normal_vec(mxs_vector *p, mxs_vector *n);

   // check worldspace pt & normal to see if forward facing
EXTERN bool r3_check_w_normal_vec(mxs_vector *p, mxs_vector *n);

   // check object space pt & normal to see if forward facing
EXTERN bool r3_check_o_normal_vec(mxs_vector *p, mxs_vector *n);

   // check 3d point & normal to see if forward facing

#define r3_check_v_normal_pt(a,b)  r3_check_v_normal_vec(&(a)->p, b)

// $Header: x:/prj/tech/libsrc/r3d/RCS/primconv.h 1.6 1998/06/18 11:26:46 JAEMZ Exp $

////////  convert between 3d points and 2d points  ////////

EXTERN void r3_phandle_to_vertex_list(int n, r3s_phandle *src, grs_point **vp);
   // convert an array of phandles into an array vertices
   // this automatically reverses the winding in a left-handed space

#define r3_phandle_to_vertex(src)    (&((src)->grp))
   // convert a phandle into a grs_vertex *

EXTERN void r3_reverse_vertex_list(int n, grs_point **src);
   // reverse 2d vertex list by hand

EXTERN void r3_maybe_reverse_vertex_list(int n, grs_point **src);
   // reverse 2d vertex list if we're in a left-handed space

// $Header: x:/prj/tech/libsrc/r3d/RCS/ctxts.h 1.14 1998/06/18 11:26:17 JAEMZ Exp $

typedef struct grs_canvas grs_canvas;

// these really belong with the h files that take these

// typedef enum for camera spaces
// clipping is optimized for clipping alot
// project is optimizd for fast projection
// unscaled is slow at projection and clipping
// linear is super fast but only good for far objects
typedef enum {
   R3_CLIPPING_SPACE=0,
   R3_PROJECT_SPACE=1,
   R3_UNSCALED_SPACE=2,
   R3_LINEAR_SPACE=3,
   R3_NUM_SPACE=4
} r3e_space;

typedef enum {
   R3_XYZ=6,    //00 01 10
   R3_XZY=9,    //00 10 01
   R3_YXZ=18,   //01 00 10
   R3_YZX=24,   //01 10 00
   R3_ZXY=33,   //10 00 01
   R3_ZYX=36,   //10 01 00
   R3_DEFANG=6  //00 01 10
} r3e_order;

// Special transform that contains explicit handedness info
typedef struct _r3s_trans {
   mxs_trans t;   // transform part of it
   int left;      // is it left handed or not                        
      // if an mxs_real is a double, we need 4 bytes more padding
} r3s_trans;

// this is the transform context
// it has all the goodies for the stack and the like
typedef struct _r3s_xform_context {
  // all the mxs_real-sized stuff
   mxs_vector cspace_vec;  // camera space vector
   r3s_trans world;  // custom world to 3d world space transform
   r3s_trans o2w;    // object to world
   r3s_trans w2v;    // world to viewer, no cspace, built from world and in(view trans);
   r3s_trans w2c;    // world to camera with cspace added, built from w2v, and space_vec
   r3s_trans o2c;    // object to camera space
   r3s_trans view_trans;   // raw view pos and matrix, for getting
   r3s_trans lin_trans; // linear trans
   mxs_vector vino;  // viewer coords in object space
   r3s_trans *stack_cur;   // pointer to next entry on stack
   r3s_trans *stack_base;  // pointer to base of stack
   int   stack_size; // current size of stack, ie, number of elements
   int   stack_max;  // maximum num elements on stack

   mxs_real zoom;     // zoom factor 90 degrees horizontal = 1
   mxs_real aspect;   // aspect ratio height/width
   mxs_vector lin_cen; // center of linear space
   mxs_real  lin_width;   // linear screen width or zero if using lin_cen
   mxs_real  lin_w;      // linear w value
   float bias_x;     // x bias to the right of center of the viewer
   float bias_y;     // y bias down of center of the viewer
   int stride;       // point size for block operations

   mxs_angvec view_ang; // raw view angles
   r3e_space cspace; // camera space
   bool w2c_invalid; // w2v invalid, need to reconcatenate before cur
   bool o2c_invalid; // set when cur is invalid
   bool world_set;   // set if the user has set world
} r3s_xform_context;

typedef struct _r3s_context {
   // canvas and related processed information
   grs_canvas *cnv;     // 2d canvas to render to
   r3s_xform_context trans;   // transform context structure har har
   r3s_clip_context clip;  // clip context structure har
   r3s_prim_context prim;  // primitive context
   // context management info
   int flags;        // yea, ok, here they are.  neat, huh?
} r3s_context;

// global context that doesn't get copied
typedef struct {
   r3s_context *cur_con; // current context, null when none
   int trans_depth;  // default nesting of transform stack
   int clip_planes;  // default number of clipping planes above the basic 5
   r3s_trans world;  // default world coordinates
   int stride;       // default size of points for block operations
   // context stack info
   r3s_context **ctxt_stack;
   int stack_depth, stack_pos;
   // move to bottom for alignment
   r3e_space space;  // default camera space
   bool in_block;    // am I in a block
} r3s_global_state;

// global context that gets changed by current context
typedef struct {
   // move to top to align if they're doubles
   mxs_real x_prj;            // x projection constant
   mxs_real y_prj;            // y projection constant
   mxs_real x_clip;           // x clip constant
   mxs_real y_clip;           // y clip constant

   fix x_off;                 // screen x offset constant
   fix y_off;                 // screen y offset constant
   int cur_stride;            // point size for block operations

// note that fields above this line should be easy to access from assembly
   r3s_xform_tab  xform_tab;  // transform function tables
   r3s_prim_tab   prim_tab;   // primitive dispatch tables
   // move to bottom for alignment
   r3e_space cur_space;       // current space
} r3s_global_context;

EXTERN r3s_global_state   r3d_state;      // global state
EXTERN r3s_global_context r3d_glob;       // global context

// everyone will hate this, as the debugger wont know what it is
// cause life is so darn sad
// so i guess we wont do it
// #define r3d_context (r3d_state.cur_con)

//------- flags for r3s_context
// flags for dealing with having a stack/multicontext model
#define R3F_CTXT_CURRENT   (1<<0)      // current context?
#define R3F_CTXT_ACTIVE    (1<<1)      // currently started/in progress?
#define R3F_CTXT_ONSTACK   (1<<2)      // on the stack?
#define R3F_CTXT_USEDONE   (1<<3)      // in a use/done block?
// flag for bonus internal/external memory fun
#define R3F_CTXT_ALLOCED   (1<<4)      // memory that r3d allocated?
#define R3F_CTXT_IAM1ST    (1<<5)      // secret interal 1st context memory
// flags for allowing persistant canvii
#define R3F_CTXT_PERSIST   (1<<6)      // a persistant context?
#define R3F_CTXT_RELOAD2D  (1<<7)      // reload canvas from 2d each frame?
// flag we need if context drives start and end frame
#define R3F_CTXT_PRIMARY   (1<<8)      // "primary, frame rate" context?
                                       // not set means a "background" context

// $Header: x:/prj/tech/libsrc/r3d/RCS/object.h 1.6 1998/06/18 11:26:24 JAEMZ Exp $
// object stack routines

// Starts an object coordinate system, with no orientation.  What happens
// is the object stack is incremented, and the new transform is
// calculated.  Sets o2c_invalid.  All of them do. 

EXTERN void r3_start_object(mxs_vector *v);
EXTERN void r3_start_object_angles(mxs_vector *v, mxs_angvec *a,r3e_order o);
EXTERN void r3_start_object_trans(mxs_trans *t);

// takes a number representing which axis to rotate about 0=x,1=y,2=z
// real angs are in radian, if you didn't know
EXTERN void r3_start_object_n(mxs_vector *v,mxs_ang ang, int n);

// These next three are useful for retardo-vision objects, and internally
// for bsp objects that are hinged.

#define r3_start_object_x(vecptr,realang) r3_start_object_n((vecptr),(realang),0)
#define r3_start_object_y(vecptr,realang) r3_start_object_n((vecptr),(realang),1)
#define r3_start_object_z(vecptr,realang) r3_start_object_n((vecptr),(realang),2)

// Pops the transform stack

EXTERN void r3_end_object();

// Exotic Transforms

// The other transforms are to go from object to world, on a point by
// point basis.  These are considered pathological, and so, aren't
// implemented as block calls or anything like that.

// Rotate a vector from object space to camera space,
// meaning this is non-orthogonal, beware
EXTERN void r3_rotate_o2c(mxs_vector *dst,mxs_vector *src);

EXTERN void r3_transform_o2w(mxs_vector *dst, mxs_vector *src);
EXTERN void r3_rotate_o2w(mxs_vector *dst, mxs_vector *src);

// this definitely assumes o2w is always orthogonal.  Because it uses
// transpose as inverse.
EXTERN void r3_transform_w2o(mxs_vector *dst, mxs_vector *src);
EXTERN void r3_rotate_w2o(mxs_vector *dst, mxs_vector *src);

// $Header: x:/prj/tech/libsrc/r3d/RCS/space.h 1.15 1998/06/18 11:27:14 JAEMZ Exp $
// Camera Space related functions

// Changes the world coordinate system to the one pointed at.  This is for
// losers who want to change for a given context after its built, or for doing
// wacky world inversion or maybe mirrors.  The handedness bit

EXTERN void r3_set_world(mxs_trans *w);
EXTERN mxs_trans *r3_get_world();

// Changes all the function pointers for xform and clipping, sets cspace and
// cspace_vec, and sets o2c_invalid, and w2c_invalid.  

EXTERN void r3_set_space(r3e_space s);
EXTERN r3e_space r3_get_space();

// Let's the user sneakily change the space for their own custom
// transform wackiness.   Note that this does not do anything to the
// clippers or any of that, so they better set it back again.

EXTERN void r3_set_space_vector(mxs_vector *v);
EXTERN mxs_vector *r3_get_space_vector();

// Routine to set the linear space mode center in world space
EXTERN void r3_set_linear_center(mxs_vector *v);

// Routine to set the linear space projected from the center of the
// screen making the screen width be world space size w
// used for top down or anything like that view
EXTERN void r3_set_linear_screen_width(mxs_real w);

// get the pixel size of something x wide at z distance from the camera,
// assumes it's centered, h means horizontal.  You can get z from a 
// transformed points z, since we're so groovy and don't scale it
// Useful for LOD calculations
EXTERN mxs_real r3_get_hsize(mxs_real z,mxs_real h);
EXTERN mxs_real r3_get_vsize(mxs_real z,mxs_real v);

// Return the scaling factor with which you get screen size.  You multiply
// by height and divide by distance to get pixel size
// Useful for LOD calculations
EXTERN mxs_real r3_get_hscale();
EXTERN mxs_real r3_get_vscale();

// Unproject points into camera space, just give it screen coords
// and the distance at which you want it from the camera
EXTERN void r3_unproject(mxs_vector *v,float z,float sx,float sy);

// Takes field of view in degrees, and the screen width in pixels
EXTERN mxs_real r3_fov_2_zoom(mxs_real degrees);

// Returns necessary zoom to get the number of pixels for that 
// width and distance.  Basically opposite of r3_get_hsize
// z and w are in world coords, pixw is in screen pixels
EXTERN mxs_real r3_hsize_2_zoom(mxs_real z,mxs_real w,mxs_real pixw);

// Get the pixel accuracy of linear space about a world point
// and radius.  This represents worst possible popping in screen
// pixels
EXTERN mxs_real r3_linear_accuracy(mxs_vector *wcen,mxs_real rad);

// Transform a plane from world space to world space, preserving dot product
// equals zero.  Assumes w2v is unitary, but the csp vector doesn't have to 
// be
// Also, you must be outside of a block
EXTERN void r3_w2c_plane(mxs_plane *dst,mxs_plane *src);

// Returns the mag2 of a rotated/tranformed point
// ie, a point in camera space
EXTERN float r3_camera_mag2(r3s_point *p);

/*
 * $Source: x:/prj/tech/libsrc/r3d/RCS/view.h $
 * $Revision: 1.7 $
 * $Author: JAEMZ $
 * $Date: 1998/06/18 11:27:15 $
 *
 * View point related functions
 *
 */

// Sets the view position, position only.  Note that orientationless cameras
// and objects all are assumed to be heading==0 pitch==0 bank==0, meaning that
// under the default world space, you all point down the x a Also, 
// o2c_invalid, and w2c_invalid get set.

EXTERN void r3_set_view(mxs_vector *v);
EXTERN mxs_trans *r3_get_view_trans();

// Sets the view transform pretty damn directly.  The meaning of it is the
// position in world space, and the columns of the matrix point along the
// viewer x, y, and z directions.

EXTERN void r3_set_view_trans(mxs_trans *t);

// Takes an angvec for angles about the x,y,z axes, and and order which
// indicates from left to right how the angles should be applied.  There
// is a default, which is XYZ which means bank the thing first, pitch i

EXTERN void r3_set_view_angles(mxs_vector *v, mxs_angvec *a,r3e_order o);

// Gets the view position in world space, and the angles in world space

EXTERN mxs_vector *r3_get_view_pos();
EXTERN mxs_angvec *r3_get_view_ang();

// This gives you the current viewer position in object space.   This
// must be in a block.  Or at least after a block and before any other
// space changing call. 

EXTERN mxs_vector *r3_get_view_in_obj();

// These are always true, don't need to be in or out of a block
// The slew function gets you the slew matrix of the viewer.  That is,
// the first column, would be the vector to move you one unit in the
// viewer x, ie forward, the second column is y, ie, left, the third
// column.

EXTERN mxs_matrix *r3_get_slew_matrix();
EXTERN mxs_vector *r3_get_forward_slew();
EXTERN mxs_vector *r3_get_left_slew();
EXTERN mxs_vector *r3_get_up_slew();

// get the view pyramid in world space
// as a set of planes that get stuffed
// you need space for five planes,
// left,top,right,bottom, front

EXTERN void r3_get_view_pyr_planes(mxs_plane *planes);

// get the view pyramid as 4 vectors
// upper left, upper right, lower right, lower left
// Note that these are deltas in world space off of the viewer position

EXTERN void r3_get_view_pyr_vecs(mxs_vector *vecs);

// Stuff a world space vector into dst describing a vector
// at screen coordinates, sx, and sy.  dst->z is equal to one
// can call at any time during a context
EXTERN void r3_get_view_vec(mxs_vector *dst,mxs_real sx,mxs_real sy);

// get and set zoom factors, defaults to 1.0 = 90 degrees
// need a current context, not in a block

EXTERN void r3_set_zoom(mxs_real zoom);
EXTERN mxs_real r3_get_zoom();

// set and get aspect ratio, since you may want to change
// it, and the 2d has no aspect per canvas
// note aspect ratio is defined as height of pixel over
// width of pixel.

EXTERN void r3_set_aspect(mxs_real aspect);
EXTERN mxs_real r3_get_aspect();

// set and get the current view canvas, this is also called internally
// assumes in context, and not in block.

EXTERN void r3_set_view_canvas(grs_canvas *canv);
EXTERN grs_canvas *r3_get_view_canvas();

// Block commands

EXTERN void r3_start_block();
EXTERN void r3_end_block();

// $Header: x:/prj/tech/libsrc/r3d/RCS/r3dctxt.h 1.7 1998/06/18 11:27:11 JAEMZ Exp $
// public functions for the context system

// super basic start and end frame, implicitly create, set and destroy a context
EXTERN r3s_context *r3_start_frame(void);
EXTERN bool r3_end_frame(void);
// for using a context you have built to start a frame
EXTERN bool r3_start_frame_context(r3s_context *ctxt);

// basic special context support, for building and playing with persistant contexts
EXTERN r3s_context *r3_alloc_context(r3s_context *ctxt,ulong flags);
EXTERN bool r3_use_context(r3s_context *ctxt);
EXTERN bool r3_done_with_context(void);
EXTERN bool r3_free_context(r3s_context *ctxt);

// fancy pants context stuff for cool people who use multicontext support
EXTERN bool r3_switch_context(r3s_context *dst);
EXTERN bool r3_push_context(r3s_context *dst);
EXTERN bool r3_pop_context(void);
EXTERN bool r3_abort_context(r3s_context *ctxt);

// driver switching calls.  Currently this state is not context related.
EXTERN void r3_use_g2(void);      // use g2, the default driver.
EXTERN void r3_use_lgd3d(void);   // use lgd3d, the looking glass direct 3d interface.
EXTERN void r3_use_null(void);    // use null driver; i.e. no rasteriztion.

// Initializing commands

EXTERN void r3_init_defaults(int trans_depth,int clip_planes,r3e_space space,int ctxt_cnt,int stride);

// simple init call that most users will use, that just uses all the default
EXTERN void r3_init(void);

EXTERN void r3_close(void);

// Sets a world coord system inherited by all subsequent context creations.  
// The default is the identity transform.  As well, the handedness bit is set
// in the transform.  If you have a current context.

EXTERN void r3_set_default_world(mxs_trans *w);

EXTERN mxs_trans *r3_get_default_world();

// Sets the default camera space that all new contexts inherit.  The default
// is R3_CLIPPING.

EXTERN void r3_set_default_space(r3e_space s);

EXTERN r3e_space r3_get_default_space();

#define R3C_OFF_LEFT    1
#define R3C_OFF_RIGHT   2
#define R3C_OFF_TOP     4
#define R3C_OFF_BOTTOM  8
#define R3C_BEHIND     16

#define R3C_NONE        0

#endif /* __R3D_H */ 
