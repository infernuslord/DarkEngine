///////////////////////////////////////////////////////////////////////////////
// $Source: x:/prj/tech/libsrc/lg/RCS/hashfns.cpp $
// $Author: TOML $
// $Date: 1998/02/24 12:54:36 $
// $Revision: 1.7 $
//
// Different flavors of the same hash
//
// Hashing based on algorithm published in C++ Report Sep. 94 (Cargill)
//

#include <lg.h>
#include <hashfns.h>

#include <ctype.h>

///////////////////////////////////////////////////////////////////////////////
//
// Table of randomly shuffled values from 0-255 generated by:
//
//    int i, r;
//    unsigned  t;
//    srand(122969);
//
//    for (i = 0; i < 256; i++)
//        g_RandomValues[i] = (unsigned )i;
//
//    for (i = 0; i < 256; i++)
//    {
//        r = rand() & 0xff;
//        t = g_RandomValues[i];
//        g_RandomValues[i] = g_RandomValues[r];
//        g_RandomValues[r] = t;
//    }
//

static unsigned g_RandomValues[256] =
{
    253, 197,  86, 221, 143, 177, 251,  29,
    130,  66, 219, 170, 250, 241, 159,  94,
    120, 107,  69,  45, 117,  82,  51, 137,
      5, 234, 238,  22, 104, 158,   2, 199,
     43, 187,  42,  31, 118, 254,  61,  70,
    185, 195, 242,  62, 106,  79,  10, 196,
     54,  58, 228,  30,  77, 244, 157,  71,
     67,  78, 211, 155, 200, 218, 252,  49,
    151, 202, 128, 246, 169, 131, 166,  40,
    164, 171,  81,  15, 186,  63, 208,  18,
    223,  85, 168,   6,   1, 132,  46,  34,
    249, 126,  83, 105, 180, 216, 102, 224,
    214, 237, 123, 114, 188, 148, 206, 183,
    222,  35,  48, 247,  25,  53, 191,  65,
    204,  24, 144,  14, 181, 100, 129,  11,
     21, 133,  37, 165,  74,  68, 111, 147,
     32, 255,  97, 207, 201,  27, 189,  84,
      9,  39, 152, 127, 176,  76, 182,  47,
    167, 233,  91,   8,  41, 154, 175,  75,
     89, 230, 229, 193,  96,  16, 150, 212,
    215, 121, 162, 220, 116,  93, 192, 227,
     44, 141, 115, 163,  98, 232, 139,  20,
    145, 172,  59,  57,  13,  56,  28,  90,
     60, 225, 149, 110, 210, 153, 194,  26,
    108,   0, 109, 178,  55, 198,  12, 146,
     52, 209,  88,  73,  36,  17, 203, 217,
      4, 136,  72, 190, 236,  87, 174, 112,
    245, 103,  99, 142, 140, 226,  33, 125,
    205, 184,  50, 179, 160, 240,  19,  80,
    239,   3,  23, 134,  92, 235,   7, 156,
     64, 135, 213, 161, 124,  38, 243, 122,
    119, 113, 173,  95, 248, 138, 101, 231
};


///////////////////////////////////////////////////////////////////////////////
//
// Hash a string
//

unsigned LGAPI HashString(const char * pszKey)
{
    const uchar *   k = (const uchar *) pszKey;
    unsigned        even = 0,
                    odd  = 0,
                    n;

    while ((n = *k++) != 0)
    {
        even = g_RandomValues[even ^ n];
        if ((n = *k++) != 0)
            odd = g_RandomValues[odd ^ n];
        else
            break;
    }

    return (even << 8) | odd;
}

///////////////////////////////////////

unsigned LGAPI HashStringCaseless(const char * pszKey)
{
    const uchar *   k = (const uchar *) pszKey;
    unsigned        even = 0,
                    odd  = 0,
                    n;

    while ((n = toupper(*k++)) != 0)
    {
        even = g_RandomValues[even ^ n];
        if ((n = toupper(*k++)) != 0)
            odd = g_RandomValues[odd ^ n];
        else
            break;
    }

    return (even << 8) | odd;
}

///////////////////////////////////////
//
// Hash a GUID
//

unsigned LGAPI HashGUID(const GUID * pID)
{
    register const DWORD *  p = (const DWORD *) pID;
    register unsigned       even,
                            odd,
                            n;
    n = *p;
    even    = g_RandomValues[n & 0xff];
    odd     = g_RandomValues[((n >> 8) & 0xff)];

    even    = g_RandomValues[even ^ (n >> 24)];
    odd     = g_RandomValues[odd ^ (n >> 16) & 0xff];
    even    = g_RandomValues[even ^ ((n >> 8) & 0xff)];
    odd     = g_RandomValues[odd  ^ (n & 0xff)];

    n = *(p+1);
    even    = g_RandomValues[even ^ (n >> 24)];
    odd     = g_RandomValues[odd  ^ ((n >> 16) & 0xff)];
    even    = g_RandomValues[even ^ ((n >> 8) & 0xff)];
    odd     = g_RandomValues[odd  ^ (n & 0xff)];

    n = *(p+2);
    even    = g_RandomValues[even ^ (n >> 24)];
    odd     = g_RandomValues[odd  ^ ((n >> 16) & 0xff)];
    even    = g_RandomValues[even ^ ((n >> 8) & 0xff)];
    odd     = g_RandomValues[odd  ^ (n & 0xff)];

    n = *(p+3);
    even    = g_RandomValues[even ^ (n >> 24)];
    odd     = g_RandomValues[odd  ^ ((n >> 16) & 0xff)];
    even    = g_RandomValues[even ^ ((n >> 8) & 0xff)];
    odd     = g_RandomValues[odd  ^ (n & 0xff)];

    return (even << 8) | odd;
}


///////////////////////////////////////
//
// Hash a pointer
//

unsigned LGAPI HashPtr(const void * p)
{
   unsigned    odd,
               even;

   odd     = g_RandomValues[(((unsigned)p >> 8) & 0xff)]; 
   even    = g_RandomValues[(unsigned)p & 0xff]; 

   odd     = g_RandomValues[odd  ^ ((unsigned)p & 0xff)]; 
   p = (const void *)((unsigned)p >> 8);
   even    = g_RandomValues[even ^ (((unsigned)p) & 0xff)];
   p = (const void *)((unsigned)p >> 8);
   odd     = g_RandomValues[odd  ^ (((unsigned)p) & 0xff)];
   p = (const void *)((unsigned)p >> 8);
   even    = g_RandomValues[even ^ ((unsigned)p)];

   return (even << 8) | odd;
}

///////////////////////////////////////
//
// Hash a long
//

// @Note (toml 02-24-98): this function is now obsoldete and should be removed
// at some time in the future. Right now, it has been left in so we don't have
// to rebuild the world. 
#undef HashLong
#pragma message("read the comment dated 02-24-98!")

EXTERN unsigned LGAPI HashLong(long key)
{
   return HashPtr((void *)key);
}

///////////////////////////////////////
//
// Hash an thing of the given size
//

unsigned LGAPI HashThing(const void * pKey, unsigned size)
{
    const uchar *       k = (const uchar *) pKey;
    unsigned            even = 0,
                        odd = 0,
                        n;

    while (size--)
    {
        n = *k++;
        even = g_RandomValues[even ^ n];
        if (size--)
        {
            n = *k++;
            odd = g_RandomValues[odd ^ n];
        }
        else
            break;
    }

    return (even << 8) | odd;
}

///////////////////////////////////////////////////////////////////////////////
